"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SshTunnel = void 0;
const util_1 = require("util");
const events_1 = require("events");
const ssh2_1 = require("ssh2");
const debug_1 = __importDefault(require("debug"));
const server_1 = __importDefault(require("socksv5/lib/server"));
const None_1 = __importDefault(require("socksv5/lib/auth/None"));
const UserPassword_1 = __importDefault(require("socksv5/lib/auth/UserPassword"));
const debug = (0, debug_1.default)('mongodb:ssh-tunnel');
function getConnectConfig(config) {
    const { localAddr, localPort, socks5Password, socks5Username, ...connectConfig } = config;
    return connectConfig;
}
function getSshTunnelConfig(config) {
    return {
        localAddr: '127.0.0.1',
        localPort: 0,
        socks5Username: undefined,
        socks5Password: undefined,
        ...config,
    };
}
class SshTunnel extends events_1.EventEmitter {
    constructor(config = {}) {
        super();
        this.connected = false;
        this.closed = false;
        this.connections = new Set();
        this.rawConfig = getSshTunnelConfig(config);
        this.sshClient = new ssh2_1.Client();
        this.sshClient.on('close', () => {
            debug('sshClient closed');
            this.connected = false;
        });
        this.forwardOut = (0, util_1.promisify)(this.sshClient.forwardOut.bind(this.sshClient));
        this.server = server_1.default.createServer(this.socks5Request.bind(this));
        if (this.rawConfig.socks5Username) {
            this.server.useAuth((0, UserPassword_1.default)((user, pass, cb) => {
                const success = this.rawConfig.socks5Username === user &&
                    this.rawConfig.socks5Password === pass;
                debug('validating auth parameters', success);
                process.nextTick(cb, success);
            }));
        }
        else {
            debug('skipping auth setup for this server');
            this.server.useAuth((0, None_1.default)());
        }
        this.serverListen = (0, util_1.promisify)(this.server.listen.bind(this.server));
        this.serverClose = (0, util_1.promisify)(this.server.close.bind(this.server));
        for (const eventName of ['close', 'error', 'listening']) {
            this.server.on(eventName, this.emit.bind(this, eventName));
        }
    }
    get config() {
        const serverAddress = this.server.address();
        return {
            ...this.rawConfig,
            localPort: (typeof serverAddress !== 'string' && (serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port)) ||
                this.rawConfig.localPort,
        };
    }
    async listen() {
        const { localPort, localAddr } = this.rawConfig;
        debug('starting to listen', { localAddr, localPort });
        await this.serverListen(localPort, localAddr);
        await this.connectSsh();
    }
    async close() {
        debug('closing SSH tunnel');
        const [maybeError] = await Promise.all([
            this.serverClose().catch((e) => e),
            this.closeSshClient(),
            this.closeOpenConnections(),
        ]);
        if (maybeError) {
            throw maybeError;
        }
    }
    async connectSsh() {
        if (this.connected) {
            debug('already connected');
            return;
        }
        if (this.connectingPromise) {
            debug('reusing connectingPromise');
            return this.connectingPromise;
        }
        if (this.closed) {
            throw new Error('Disconnected.');
        }
        debug('creating SSH connection');
        this.connectingPromise = Promise.race([
            (0, events_1.once)(this.sshClient, 'error').then(([err]) => {
                throw err;
            }),
            (() => {
                const waitForReady = (0, events_1.once)(this.sshClient, 'ready').then(() => { });
                this.sshClient.connect(getConnectConfig(this.rawConfig));
                return waitForReady;
            })(),
        ]);
        try {
            await this.connectingPromise;
        }
        catch (err) {
            debug('failed to establish SSH connection', err);
            delete this.connectingPromise;
            await this.serverClose();
            throw err;
        }
        delete this.connectingPromise;
        this.connected = true;
        debug('created SSH connection');
    }
    async closeSshClient() {
        if (!this.connected) {
            return;
        }
        this.closed = true;
        const promise = (0, events_1.once)(this.sshClient, 'close');
        this.sshClient.end();
        return promise;
    }
    async closeOpenConnections() {
        const waitForClose = [];
        this.connections.forEach((socket) => {
            waitForClose.push((0, events_1.once)(socket, 'close'));
            socket.destroy();
        });
        await Promise.all(waitForClose);
        this.connections.clear();
    }
    async socks5Request(info, accept, deny) {
        debug('receiving socks5 forwarding request', info);
        let socket = null;
        try {
            await this.connectSsh();
            let channel;
            try {
                channel = await this.forwardOut(info.srcAddr, info.srcPort, info.dstAddr, info.dstPort);
            }
            catch (err) {
                if (err.message === 'Not connected') {
                    this.connected = false;
                    debug('error forwarding. retrying..', info, err);
                    await this.connectSsh();
                    channel = await this.forwardOut(info.srcAddr, info.srcPort, info.dstAddr, info.dstPort);
                }
                else {
                    throw err;
                }
            }
            debug('channel opened, accepting socks5 request', info);
            socket = accept(true);
            this.connections.add(socket);
            socket.on('error', (err) => {
                var _a;
                debug('error on socksv5 socket', info, err);
                err.origin = (_a = err.origin) !== null && _a !== void 0 ? _a : 'connection';
                this.server.emit('error', err);
            });
            socket.once('close', () => {
                debug('socksv5 socket closed, removing from set');
                this.connections.delete(socket);
            });
            socket.pipe(channel).pipe(socket);
        }
        catch (err) {
            debug('caught error, rejecting socks5 request', info, err);
            deny();
            if (socket) {
                err.origin = 'ssh-client';
                socket.destroy(err);
            }
        }
    }
}
exports.SshTunnel = SshTunnel;
exports.default = SshTunnel;
//# sourceMappingURL=index.js.map